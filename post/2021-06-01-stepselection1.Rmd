---
title: "Step Selection Analysis Part 1 - Movement Simulation"
summary: "Step selection analysis is a very powerful statistical method that allows to investigate habitat and movement preferences of animals using GPS data. In this first part, we are going to simulate animal movement, also using the step selection framework. We will later analyse this data in part 2 and 3."
author: "David D. Hofmann"
date: 2021-06-01T18:00:00-05:00
categories: ["R"]
tags: ["R", "movement", "simulation", "step selection function"]
image: "img/post_stepselection1.jpg"
output:
  blogdown::html_page:
    highlight: tango
    toc: true
editor_options:
  chunk_output_type: console
---

# General Introduction
This is the first part of a three-part series on step selection functions. Step
selection functions are...

Because I'd like to into as much detail as I can but still keep blogs reasonably
short, I have decided to split the project into three distinct parts. Part I
will be dedicated entirely to generating, or in other words *simulating*, data
that we are going to use afterwards. By simulating the data we are in total
control of all parameters and know exactly what the final models should tell us.
In addition, the simulation process will already expose you to the most
important concepts for step selection analysis. In part II, we will then go on
and treat the simulated data as if it was collected on real animals using GPS
collars and transform it so that we can use it in the step selection framework.
Finally, in part III, we apply conditional logistic regression models to analyse
the data and learn about the preferences of simulated individuals. If everything
goes well, we should be able to estimate the preferences that we initially used
to simulate the data!

During this project, you will learn about a broad variety of concepts, including
the simulation of spatial layers, the simulation of movement, fitting step
selection functions, parallel computing, accessing C++ code from within R,
conditional logistic regression and its implementation in various r-packages.
Thereby, I hope to equip you with all you need to conduct your own step
selection analysis. The only pre-requisite needed for this series is a basic
understanding of R and the ability to conduct basical spatial data manipulation
in R. So let's get started!

# Introduction
In this first part, we will simulate a set of spatial layers and simulate
individuals moving across those layers.

# Simulating Habitat Layers
We will generate to different habitat layers; one rendering *elevation* (elev)
and one representing *distance to home* (dist). Both these layers are
continuous, but of course one could also have categorical layers (e.g. land
cover). To generate the elevation layer, we are going to make use of the
`RandomFields` package. This package will allow us to simulate spatially
correlated data. To make this work, we first define a data-generating model with
`RMexp()` and then we use the function `RFsimulate()` to simulate values for a
desired layer-size.

```{r}
# Load required packages
library(raster)        # To handle spatial data
library(RandomFields)  # To simulate spatially correlated layer

# Specify model
elev <- RMexp(var = 5, scale = 10) +
  RMnugget(var = 1) +
  RMtrend(mean = 0)

# Simulate data from model (on layer with 200 x 200 cells)
elev <- RFsimulate(elev, x = 1:200, y = 1:200)
elev <- raster(elev)

# Visualize
plot(elev, main = "Elevation", horizontal = T, axes = F, box = F)
axis(1)
axis(2)

```

Now that we simulated a simple elevation layer, we can go on and prepare a layer
that indicates the *distance to home*. For this, we first need to define where
home is. Hence, let's assume that home lies at center of the landscape and let's
define a spatial point for it.

```{r}
# Create Spatial Point at the center of the landscape
home <- coordinates(elev)
home <- colMeans(home)
home <- SpatialPoints(t(home))

```

With tis, it is relatively straight forward to calculate the distance from home
for any raster-cell in our landscape.

```{r}
# Calculate distance to center
dist <- distanceFromPoints(elev, home)

# Visualize it
plot(dist, main = "Distance to Home", horizontal = T, axes = F, box = F)
plot(home, add = T)
axis(1)
axis(2)
```

To make our lifes easier, let's normalize the generated layers. This will
prevent some numerical issues later. For normalization, I'll use the formula: x
- mean(x) / sd(x). Once the layers are normalized, we put them into a single
rasterstack and name each layer nicely.

```{r}
# Normalize both covariates
elev <- (elev - cellStats(elev, mean)) / cellStats(elev, sd)
dist <- (dist - cellStats(dist, mean)) / cellStats(dist, sd)

# Put covariate layers into a stack
covars <- stack(elev, dist)
names(covars) <- c("elev", "dist")

# Visualize final layers
rasterVis::levelplot(covars, at = seq(-5, 5, length = 50))
```

This already concludes our preparation of spatial layers. Now let's move on see
how we can simulate some movement on those layers.

# Simulating Movement
To simulate movement, there are myriads of different approaches, ranging from
... to ... However, since we're going to analyse the data using step selection
functions, it might be sensible to try and mimic the step selection logic when
simulating movement. To understand how step selections work, take a look at the
figure below.

```{r}
# Set seed for reproducability
set.seed(123456)

# Generate a pseudo-track
gps <- data.frame(
    x = c(1, 2, 5, 8, 10, 11)
  , y = c(1, 5, 3.3, 3, 6, 8)
)

# Generate a set of pseudo random steps (except for first step)
random <- lapply(2:(nrow(gps) - 1), function(x){
  rand <- lapply(1:5, function(y){
    rbind(
        gps[x, ]
      , gps[x, ] + rnorm(n = 2, sd = 2)
    )
  })
 return(rand)
})
random <- unlist(random, recursive = F)

# Visualize
plot(y ~ x, data = gps, type = "o", pch = 19, axes = F, xlim = c(0, 12), ylim = c(0, 12))
lines(y ~ x, data = gps_added, lty = 2)
lapply(random, function(z){
  lines(y ~ x, data = z, lty = 2)
})
points(y ~ x, data = gps, pch = 19)
points(y ~ x, data = gps[1, ], pch = 15, col = "green", cex = 1.4)
axis(1)
axis(2)
legend("topleft"
  , pch = c(15, 19, NA)
  , lty = c(NA, 1, 2)
  , col = c("green", "black", "black")
  , legend = c("start", "observed steps", "random steps")
  , cex = 0.7
)

```


We now go through these steps, one by one. However, later we will combine all of
the into a single function, which will enable us to more easily repeat
simulations across multiple individuals.

## Step Lengths & Turning Angles
In order to sample step lengths and turning angles we are going to use two
different distributions. We will use the uniform distribution (on -pi to +pi)
for turning angles, and the gamma distribution for step lengths. Let's sample
some values from the two distributions and visualize how they are distributed.

```{r}
# Sample values
turning_angles <- runif(n = 5000, min = -pi, max = pi)
step_lengths <- rgamma(n = 5000, shape = 3, scale = )

par(mfrow = c(1, 2))
# Histogram of Turning Angles
hist(turning_angles, breaks = 50, xlab = "Turning Angle", axes = F, freq = F, col = "cornflowerblue", main = "Turning Angles")
axis(side = 1, at = seq(-pi, pi, by = pi/2), labels=c(expression(-pi), expression(-pi/2), "0", expression(pi/2), expression(pi)))
axis(side = 2)

# Histogram of Step Lengths
hist(step_lengths, breaks = 50, xlab = "Step Length (px)", axes = F, freq = F, col = "cornflowerblue", main = "Step Lengths")
axis(side = 1)
axis(side = 2)

```

# Further Reading
* Great tutorials on how to use the rayshader package (https://www.rayshader.com/)
* marmapr vignette (https://cran.r-project.org/web/packages/marmap/vignettes/marmap-DataAnalysis.pdf)
* Some further information on terrain characteristics (http://search.r-project.org/library/raster/html/terrain.html)

# Session Information
```{r, warnings = F, messages = F, echo = F}
sessionInfo()
```

